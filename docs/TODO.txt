=== Foremost ===
*) Convert std and min to modules loaded with __import__
*) Create tests and anything needed for the testing framework
- std.data
- std.static
- std.font
- std.typeset
- std.cond (post-implementation)
- std.exec (post-implementation)
- std.calc (post-implementation)
- min.tilemap
- min.spritemap
- min.tile
- min.sprite
- min.tile3
- min.sprite3
- Translations (rotations/flips)
*) New class to manage strings. Literal chars in strings can be utf8.
   $uXXXX is utf16. And $XX is binary. Interact with it like a string.. 

=== etc ===
T) Syntax, Parser) * - x i should be literals when by themselves
*) rplref) Special "Caller" ref. Refers to calling struct. Passes caller to 
           subsequent references.
T) Parse/Range) Hex in ranges, $ can come before a number to indicate hex
*) std) cond, exec, and calc structs:
   cond) Evaluates "expr". If result is true check if "truex" is defined,
         if so, exec that and return the result. If not return "true"
         (default value is 1). If result is false, do the same with "falsex"
         and "false".
   exec) Exec "exec" which is like cond/calc's expr except it assumes the format
         is [command,[expr]] where you don't need to nest expr. (Note: this
         applies to truex and falsex as well, they're basically shorthand for
         making this struct.) Also assumes concatenation in expr, use sublists
         for calculations.
   calc) Evaluates "expr" and returns the result.
   Note: return means basic data
   translit) Define a transliteration, useful for converting data/strings to the
             actual data needed. Keys "out" and "in" match by char to char.
             "in" must be non-unicode. They are short for outside/inside
             Pass the name of a translit struct in the format section of a data
             struct to use it to convert data. Basic data will always be the name
*) Make "file" "folder" and "ext" keys globally useful and not managed by the
   structs themselves. "export" and "import" can be global too. Structs can define
   if they do manage data or not and what their default "ext" is. When a struct
   makes its filename it will combine all parent structs' folder values into its
   path, use its own filename as the name and bubble up for explicit ext (defaulting
   to its own default) if the ext is not already in the filename.
   Defaults: If a struct ex/imports then its name becomes "file", if it does not
   then its name becomes "folder". eg. static MyFolder { tilemap MyTilemapFile { ... } }
   Will save to ./MyFolder/MyTilemapFile.png (assuming png is tilemap's default ext)
*) rplref) Able to reference internal stuff via .. or ! or something idk.
           Possibilities include: name, basic (just for explicitness, maybe it
           doesn't return the name as default), file (calculated path/filename/ext),
           link (looks up the key of the name that this key is in)
